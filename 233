<?xml version="1.0" ?>
<cherrytree>
	<node custom_icon_id="0" foreground="" is_bold="False" name="base" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1626052212.69" ts_lastsave="1626916551.65" unique_id="1">
		<rich_text>
echo value=$(hostname); exit
netstat -anp |grep



</rich_text>
		<rich_text link="webs https://www.cnblogs.com/mianbaoshu/p/12069877.html">shell 中()、[]、{}、(())、[[]]等各种括号的使用</rich_text>
		<rich_text>
代码中的 [] 执行基本的算数运算，如：result=$</rich_text>
		<rich_text foreground="#7a0874" weight="heavy">[</rich_text>
		<rich_text weight="heavy">a+b</rich_text>
		<rich_text foreground="#7a0874" weight="heavy">]</rich_text>
		<rich_text>


uname -a
 cat /etc/redhat-release : 当前系统是啥？centos?


su - ccs_master -c pwd

系统日志： tail -f /var/log/messages

# 检查路径是否为绝对路径
local match=$(echo ${path} | grep -E (|/)(.){1,}($|/)|[/]) [/]非/开头

local 局部变量
set 查看所有变量，包括自定义变量


netstat -a | awk '/tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}' 统计机器中网络连接各个状态个数

declare -A是定义一个map
while do shift 移动参数
expect
set timeout 30
查服务
which 命令
systemctl list-unit-files | grep pacemaker 进程

cp -r 递归，文件不需要
cp -f 覆盖

echo -n 不换行
currentdir=$(cd $(dirname $0); pwd)
toppath=$(dirname $current_dir)


alter role ccs_dba password 'huawei12#$';

</rich_text>
		<rich_text foreground="#4d4d4d" link="webs https://my.oschina.net/lxcong/blog/143904">LVS</rich_text>
		<rich_text>

重要的二进制位于 /bin(用户二进制)以及 /sbin(系统二进制)中。不重要的二进制(如图形环境或Office 工具)安装在/usr/bin 和 /usr/sbin中


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

</rich_text>
		<rich_text link="webs https://www.jianshu.com/p/a9c8e2cb6155">shell 命令</rich_text>
		<rich_text>
</rich_text>
		<rich_text link="webs https://www.cnblogs.com/logsharing/p/8182844.html">Shell命令——文件目录</rich_text>
		<rich_text>



</rich_text>
		<node custom_icon_id="0" foreground="" is_bold="False" name="awk" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1626052559.26" ts_lastsave="1626761935.79" unique_id="9">
			<rich_text>/tmp/test&gt;ll a
-rw-rw-r-- 1 admin admin 0 8月 11 10:58 a
/tmp/test&gt;ll a |awk '{print NF}' 
9
/tmp/test&gt;ll a |awk '{print $NF}'
a
awk -F= 分隔符</rich_text>
		</node>
		<node custom_icon_id="0" foreground="" is_bold="False" name="array" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1626076501.44" ts_lastsave="1626761959.12" unique_id="23">
			<rich_text>
</rich_text>
			<rich_text link="webs https://blog.csdn.net/jerry_1126/article/details/52027539">Shell中的数组及其相关操作</rich_text>
			<rich_text>

备注:
1) 使用${array_name[@]} 或者 ${array_name[*]} 都可以全部显示数组中的元素
2) 同样道理${#array_name[@]} 或者 ${#array_name[*]}都可以用来求数组的长度
3）求数组中元素的长度方法有很多，相当于求字符串的长度
</rich_text>
		</node>
		<node custom_icon_id="0" foreground="" is_bold="False" name="chmod" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1626058573.27" ts_lastsave="1626761945.6" unique_id="18">
			<rich_text>数字权限使用格式
在这种使用方式中，首先我们需要了解数字如何表示权限。 首先，我们规定 数字 4 、2 和 1表示读、写、执行权限（具体原因可见下节权限详解内容），即 r=4，w=2，x=1 。此时其他的权限组合也可以用其他的八进制数字表示出来，

如：

rwx = 4 + 2 + 1 = 7

rw = 4 + 2 = 6

rx = 4 +1 = 5

即

若要同时设置 rwx (可读写运行） 权限则将该权限位 设置 为 4 + 2 + 1 = 7

若要同时设置 rw- （可读写不可运行）权限则将该权限位 设置 为 4 + 2 = 6

若要同时设置 r-x （可读可运行不可写）权限则将该权限位 设置 为 4 +1 = 5

</rich_text>
			<rich_text link="webs https://blog.csdn.net/u013197629/article/details/73608613">原文链接</rich_text>
		</node>
		<node custom_icon_id="0" foreground="" is_bold="False" name="cp" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1626081156.74" ts_lastsave="1627371483.18" unique_id="26">
			<rich_text>


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

\cp：

linux中cp指令前面加反斜杠在cp指令前面加反斜杠可以不弹出是否覆盖的询问而直接覆盖！
如：cp /app/WEB-INF/com/cfg.properties /app_bak/WEB-INF/com/cfg.properties 会弹出询问是否覆盖
　　\cp /app/WEB-INF/com/cfg.properties /app_bak/WEB-INF/com/cfg.properties 则不会询问

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

</rich_text>
			<rich_text weight="heavy">参数说明</rich_text>
			<rich_text>：
• -a：此选项通常在复制目录时使用，它保留链接、文件属性，并复制目录下的所有内容。其作用等于dpR参数组合。
• -d：复制时保留链接。这里所说的链接相当于 Windows 系统中的快捷方式。
• -f：覆盖已经存在的目标文件而不给出提示。
• -i：与 -f 选项相反，在覆盖目标文件之前给出提示，要求用户确认是否覆盖，回答 y 时目标文件将被覆盖。
• -p：除复制文件的内容外，还把修改时间和访问权限也复制到新文件中。
• -r：若给出的源文件是一个目录文件，此时将复制该目录下所有的子目录和文件。
• -l：不复制文件，只是生成链接文件。</rich_text>
			<rich_text weight="heavy">
</rich_text>
			<rich_text>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</rich_text>
			<rich_text link="webs https://www.runoob.com/linux/linux-comm-scp.html">scp</rich_text>
			<rich_text>

scp -rp /opt/ywx1064164/install root@selinux-node1:/opt/ywx1064164</rich_text>
		</node>
		<node custom_icon_id="0" foreground="" is_bold="False" name="chown" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1626082788.23" ts_lastsave="1626761978.48" unique_id="27">
			<rich_text>
</rich_text>
			<rich_text link="webs https://www.cnblogs.com/fanweisheng/p/11108713.html">chown权限命令</rich_text>
			<rich_text>

-h 更改遇到的符号链接的所有权，而非符号链接指向的文件或目录的所有权。 当遇到符号链接而您未指定 -h 标志时，chown 命令更改链接指向的文件或目录的所有权，而非链接本身的所有权。如果指定 -R 标志，chown 命令递归地降序指定的目录。-H 如果指定了 -R 选项，并且引用类型目录的文件的符号链接在命令行上指定，chown 变量会更改由符号引用的目录的用户标识（和组标识，如果已指定）和所有在该目录下的文件层次结构中的所有文件。</rich_text>
		</node>
		<node custom_icon_id="0" foreground="" is_bold="False" name="find" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1626070449.61" ts_lastsave="1626916317.7" unique_id="20">
			<rich_text>

某个目录及其下级目录查找：
</rich_text>
			<rich_text family="monospace" foreground="#61aeee">find ./denglishang/ -maxdepth 2 -name </rich_text>
			<rich_text family="monospace" foreground="#98c379">&quot;*.c&quot;</rich_text>
			<rich_text family="monospace"> -o -name </rich_text>
			<rich_text family="monospace" foreground="#98c379">&quot;*.sh&quot;</rich_text>
			<rich_text family="monospace"> -o -name </rich_text>
			<rich_text family="monospace" foreground="#98c379">&quot;*.js&quot;</rich_text>
			<rich_text>

 
</rich_text>
			<rich_text link="webs https://blog.csdn.net/u013008795/article/details/88707613">find 查找命令</rich_text>
			<rich_text>

</rich_text>
			<node custom_icon_id="0" foreground="" is_bold="False" name="dos2unix" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1626916313.69" ts_lastsave="1627521317.99" unique_id="64">
				<rich_text> find ./ -type f | xargs dos2unix
 
</rich_text>
				<rich_text foreground="#808080"># master安装成功后配置master访问ignite目录权限
</rich_text>
				<rich_text>ignite_work_path=</rich_text>
				<rich_text foreground="#cc7832">$</rich_text>
				<rich_text>{IGNITE_INSTALL_PATH}/batch/ignite/ignite/work
[ -d </rich_text>
				<rich_text foreground="#cc7832">$</rich_text>
				<rich_text>{ignite_work_path} ] </rich_text>
				<rich_text foreground="#cc7832">&amp;&amp; </rich_text>
				<rich_text foreground="#c57633">setfacl </rich_text>
				<rich_text>-m u:</rich_text>
				<rich_text foreground="#6a8759">&quot;</rich_text>
				<rich_text>$MASTER_USER</rich_text>
				<rich_text foreground="#6a8759">&quot;</rich_text>
				<rich_text>:rwx </rich_text>
				<rich_text foreground="#cc7832">$</rich_text>
				<rich_text>{ignite_work_path}
[ -d </rich_text>
				<rich_text foreground="#cc7832">$</rich_text>
				<rich_text>{ignite_work_path}/db ] </rich_text>
				<rich_text foreground="#cc7832">&amp;&amp; </rich_text>
				<rich_text foreground="#c57633">setfacl </rich_text>
				<rich_text>-m u:</rich_text>
				<rich_text foreground="#6a8759">&quot;</rich_text>
				<rich_text>$MASTER_USER</rich_text>
				<rich_text foreground="#6a8759">&quot;</rich_text>
				<rich_text>:rwx </rich_text>
				<rich_text foreground="#cc7832">$</rich_text>
				<rich_text>{ignite_work_path}/db
[ -d </rich_text>
				<rich_text foreground="#cc7832">$</rich_text>
				<rich_text>{ignite_work_path}/binary_meta ] </rich_text>
				<rich_text foreground="#cc7832">&amp;&amp; </rich_text>
				<rich_text foreground="#c57633">setfacl </rich_text>
				<rich_text>-m u:</rich_text>
				<rich_text foreground="#6a8759">&quot;</rich_text>
				<rich_text>$MASTER_USER</rich_text>
				<rich_text foreground="#6a8759">&quot;</rich_text>
				<rich_text>:rwx -R </rich_text>
				<rich_text foreground="#cc7832">$</rich_text>
				<rich_text>{ignite_work_path}/binary_meta
[ -d </rich_text>
				<rich_text foreground="#cc7832">$</rich_text>
				<rich_text>{ignite_work_path}/diagnostic ] </rich_text>
				<rich_text foreground="#cc7832">&amp;&amp; </rich_text>
				<rich_text foreground="#c57633">setfacl </rich_text>
				<rich_text>-m u:</rich_text>
				<rich_text foreground="#6a8759">&quot;</rich_text>
				<rich_text>$MASTER_USER</rich_text>
				<rich_text foreground="#6a8759">&quot;</rich_text>
				<rich_text>:rwx -R </rich_text>
				<rich_text foreground="#cc7832">$</rich_text>
				<rich_text>{ignite_work_path}/diagnostic
[ -d </rich_text>
				<rich_text foreground="#cc7832">$</rich_text>
				<rich_text>{ignite_work_path}/marshaller ] </rich_text>
				<rich_text foreground="#cc7832">&amp;&amp; </rich_text>
				<rich_text foreground="#c57633">setfacl </rich_text>
				<rich_text>-m u:</rich_text>
				<rich_text foreground="#6a8759">&quot;</rich_text>
				<rich_text>$MASTER_USER</rich_text>
				<rich_text foreground="#6a8759">&quot;</rich_text>
				<rich_text>:rwx -R </rich_text>
				<rich_text foreground="#cc7832">$</rich_text>
				<rich_text>{ignite_work_path}/marshaller
[ -d </rich_text>
				<rich_text foreground="#cc7832">$</rich_text>
				<rich_text>{ignite_work_path}/log ] </rich_text>
				<rich_text foreground="#cc7832">&amp;&amp; </rich_text>
				<rich_text foreground="#c57633">chmod </rich_text>
				<rich_text foreground="#6897bb">700 </rich_text>
				<rich_text foreground="#cc7832">$</rich_text>
				<rich_text>{ignite_work_path}/log </rich_text>
				<rich_text foreground="#cc7832">&amp;&amp; </rich_text>
				<rich_text foreground="#c57633">chmod </rich_text>
				<rich_text foreground="#6897bb">600 </rich_text>
				<rich_text foreground="#cc7832">$</rich_text>
				<rich_text>{ignite_work_path}/log/*
</rich_text>
			</node>
		</node>
		<node custom_icon_id="0" foreground="" is_bold="False" name="expect" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1626075200.02" ts_lastsave="1626761952.46" unique_id="22">
			<rich_text>
</rich_text>
			<rich_text link="webs https://blog.csdn.net/wzl1217333452/article/details/107577904">Linux expect用法介绍</rich_text>
			<rich_text>


</rich_text>
			<rich_text link="webs https://blog.csdn.net/u013600225/article/details/74614152">如何获得expect中spawn的命令的返回值？</rich_text>
			<rich_text>
</rich_text>
		</node>
		<node custom_icon_id="0" foreground="" is_bold="False" name="etcd" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1626052442.61" ts_lastsave="1626761930.55" unique_id="6">
			<rich_text>etcd

export ENDPOINTS=71.54.52.116:2379,71.54.52.113:2379,71.54.52.114:2379
etcdctl --write-out=table --endpoints=&quot;71.54.52.116:2379,71.54.52.113:2379,71.54.52.114:2379&quot; endpoint status

export ENDPOINTS=&quot;71.54.52.116:2379,71.54.52.113:2379,71.54.52.114:2379&quot;
etcdctl --write-out=table --endpoints=$ENDPOINTS member list

etcdctl --user=&quot;root&quot; get &quot;master_leader&quot; 命令后补充--command-timeout=20s</rich_text>
		</node>
		<node custom_icon_id="0" foreground="" is_bold="False" name="eval" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1626058215.04" ts_lastsave="1626761937.57" unique_id="17">
			<rich_text>
</rich_text>
			<rich_text link="webs https://blog.csdn.net/baidu_37964071/article/details/80930704">``和$()的区别及eval详解</rich_text>
			<rich_text>

</rich_text>
			<rich_text foreground="#c57633">local </rich_text>
			<rich_text>postgres_home_dir=</rich_text>
			<rich_text foreground="#cc7832">$</rich_text>
			<rich_text foreground="#c57633">(eval </rich_text>
			<rich_text>echo ~postgres</rich_text>
			<rich_text foreground="#c57633">)</rich_text>
		</node>
		<node custom_icon_id="0" foreground="" is_bold="False" name="expr" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1626080853.35" ts_lastsave="1626761971.2" unique_id="25">
			<rich_text>other_permission=</rich_text>
			<rich_text foreground="#cc7832">$</rich_text>
			<rich_text foreground="#c57633">(expr </rich_text>
			<rich_text>$permission % </rich_text>
			<rich_text foreground="#6897bb">10</rich_text>
			<rich_text foreground="#c57633">)</rich_text>
		</node>
		<node custom_icon_id="0" foreground="" is_bold="False" name="grep" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1626052454.23" ts_lastsave="1626918979.78" unique_id="7">
			<rich_text>
grep -w 精确匹配
grep -v 排除 grep grep
grep -e 一个参数pattern
grep -E （egrep）组合pattern
grep -c 统计字符串个数
grep -q 静默 if判断


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

</rich_text>
			<rich_text link="webs https://www.cnblogs.com/bass6/p/5523654.html">grep' \b\b'</rich_text>
			<rich_text>
\b单词锁定符,如: '\bgrep\b'只匹配grep

</rich_text>
			<rich_text foreground="#cc7832">function </rich_text>
			<rich_text foreground="#ffc66d">get_val</rich_text>
			<rich_text>() {
    ITEM=$1

    </rich_text>
			<rich_text foreground="#c57633">local </rich_text>
			<rich_text>value=</rich_text>
			<rich_text foreground="#cc7832">$</rich_text>
			<rich_text foreground="#c57633">(grep </rich_text>
			<rich_text foreground="#6a8759">&quot;^\s*\b</rich_text>
			<rich_text>$ITEM</rich_text>
			<rich_text foreground="#6a8759">\s*=&quot; &quot;</rich_text>
			<rich_text>$SETTING_PATH</rich_text>
			<rich_text foreground="#6a8759">&quot; </rich_text>
			<rich_text>| </rich_text>
			<rich_text foreground="#c57633">sed </rich_text>
			<rich_text foreground="#6a8759">&quot;s/^\\s*</rich_text>
			<rich_text>$ITEM</rich_text>
			<rich_text foreground="#6a8759">\\s*=//&quot;</rich_text>
			<rich_text foreground="#c57633">)
    echo </rich_text>
			<rich_text foreground="#6a8759">&quot;</rich_text>
			<rich_text>$value</rich_text>
			<rich_text foreground="#6a8759">&quot; </rich_text>
			<rich_text>| </rich_text>
			<rich_text foreground="#c57633">xargs
</rich_text>
			<rich_text>}

</rich_text>
		</node>
		<node custom_icon_id="0" foreground="" is_bold="False" name="kill" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1626140218.06" ts_lastsave="1626761968.38" unique_id="29">
			<rich_text>kill -0 pid
用来检测进程是否存在，当进程不存在时，kill -0会报错
kill -0 $pid &gt; /dev/null 2&gt;&amp;1
</rich_text>
		</node>
		<node custom_icon_id="0" foreground="" is_bold="False" name="mount" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1626052407.98" ts_lastsave="1627274102.9" unique_id="5">
			<rich_text>
</rich_text>
			<rich_text link="webs https://blog.csdn.net/qq_22083251/article/details/80420403">can’t find /mnt in /etc/fstab问题的解决和fstab详解</rich_text>
			<rich_text>

</rich_text>
			<rich_text link="webs https://blog.csdn.net/bruno231/article/details/7782890">nfs -o nolock</rich_text>
			<rich_text>

</rich_text>
			<rich_text link="webs https://www.cnblogs.com/mingziday/archive/2012/12/07/2806417.html">nfs-utils源码安装</rich_text>
			<rich_text>


</rich_text>
			<rich_text link="webs https://blog.csdn.net/qq_36792209/article/details/82695380">问题解决：tar: Removing leading `//' from member names</rich_text>
			<rich_text>



共享目录
chown -R master /share/license
chown 770 /share/license
vi /etc/exports

mount
    /mounted_package *(rw,no_subtree_check,fsid=10,no_root_squash)
    /opts  71.54.52.0/24(insecure,rw,sync,no_root_squash)

    systemctl stop nfs
    systemctl start nfs
    systemctl enable nfs
    
        mount -t nfs -o rw,soft,timeo=30,retry=3 71.54.52.116:/testopt /testopt
        
        
        mount -t nfs 71.54.46.45:/opt  /opt
        mount -t nfs 71.54.46.45:/share /share
        mount -t nfs 71.54.52.117:/opt /topt


Mount挂载操作，使用NFS方式挂载到文件服务器，出错如下： bad option; for several filesystems (e.g. nfs, cifs) you might need a /sbin/mount. helper program.

rpm -ivh gssproxy-0.4.1-7.h1.x86_64.rpm
rpm -ivh nfs-utils-1.3.0-0.9.h5.x86_64.rpm


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
unmount -fl


</rich_text>
		</node>
		<node custom_icon_id="0" foreground="" is_bold="False" name="read" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1626761996.18" ts_lastsave="1626762026.15" unique_id="59">
			<rich_text>
</rich_text>
			<rich_text link="webs https://www.cnblogs.com/klb561/p/9245696.html">Linux中read命令的用法—（6/30）</rich_text>
			<rich_text>

read -p &quot;Input passwd:&quot; -s Passwd
echo $Passwd</rich_text>
		</node>
		<node custom_icon_id="0" foreground="" is_bold="False" name="rm" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1626231135.35" ts_lastsave="1627521517.95" unique_id="53">
			<rich_text>
</rich_text>
			<rich_text link="webs https://blog.csdn.net/weixin_42493346/article/details/87928841">在linux中出现rm -rf 无法删除的文件怎么办</rich_text>
			<rich_text>

lsof +D 再加上无法删除文件的目录，把显示的process都kill掉，然后再rm就可以了。

用fuser处理
# fuser -km /dev/shm

# umount /dev/shm

# mount /dev/shm

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

chattr -i webapps   //去除i属性
 rm -rf webapps      //删除文件夹
 
 
 
</rich_text>
		</node>
		<node custom_icon_id="0" foreground="" is_bold="False" name="stat" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1626080752.74" ts_lastsave="1626761962.59" unique_id="24">
			<rich_text>
</rich_text>
			<rich_text link="webs https://blog.csdn.net/Wxq960906/article/details/80531595">stat用法</rich_text>
			<rich_text>
</rich_text>
		</node>
		<node custom_icon_id="0" foreground="" is_bold="False" name="selinux" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1626052380.9" ts_lastsave="1626761928.21" unique_id="4">
			<rich_text>去掉加固
防火墙，selinux
/usr/sbin/sestatus -v

getenforce -&gt; 44 enforcing
sed -i s#SELINUX=enforcing#SELINUX=permissive#g /etc/selinux/config
sed -i s#SELINUX=enforcing#SELINUX=permissive#g /etc/sysconfig/selinux</rich_text>
		</node>
		<node custom_icon_id="0" foreground="" is_bold="False" name="sed" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1626052620.63" ts_lastsave="1626761976.36" unique_id="11">
			<rich_text>
</rich_text>
			<rich_text link="webs https://www.jianshu.com/p/a721a3e4030e">sed用法详解</rich_text>
			<rich_text>

</rich_text>
			<rich_text link="webs https://blog.csdn.net/qq_44714603/article/details/88222931">sed中的-n</rich_text>
			<rich_text>

sed -i 就是直接对文本文件进行操作的
sed 's/(.)([0-9]).*/\2/g' test.txt | tr '0-9' 'A-Z'
sed '/p' p再将匹配到的内容打印出来，

options 部分：
-n 静默输出(不打印默认输出)
-e 给予sed多个命令的时候需要-e选项


#sed -n '1p' passwd p是打印函数

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 cat -n test.conf | sed -n '/VI_CCP_DB_HA/,/virtual_router_id/p'
 
 test.conf：
        listen_addresses = 'VIP'
        VI_CCP_DB_HA

        2333
        virtual_router_id
        
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

</rich_text>
			<rich_text link="webs https://www.runoob.com/linux/linux-comm-sed.html">Linux sed 命令</rich_text>
			<rich_text>

以行为单位的新增/删除
将 /etc/passwd 的内容列出并且列印行号，同时，请将第 2~5 行删除！

nl /etc/passwd | sed '2,5d'

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

sed 里有变量

echo &quot;sed -i '${parm}s/2333/3222/g'&quot; test.conf|bash

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

</rich_text>
			<rich_text weight="heavy">sed的替换命令格式</rich_text>
			<rich_text>：
s/A/B/g 或者 s#A#B#g 或者 s_A_B_g#。

只是分隔符而已，为满足格式需要。将所有制表符\t替换为|g表示全局替换，有多少次替换多少次。
s 是替代命令. s/表达式/replacement/

g(GLOBAL)的作用从下例可以看出
    g -- 全部替代
    无g -- 只替代每行第一个。

空白用t替代。如果你的unix中 \t表示tab键，则用tab键替代。
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~









</rich_text>
		</node>
		<node custom_icon_id="0" foreground="" is_bold="False" name="tar" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1626052364.57" ts_lastsave="1626761923.87" unique_id="3">
			<rich_text>
</rich_text>
			<rich_text link="webs https://www.runoob.com/linux/linux-comm-tar.html">Linux tar 命令</rich_text>
			<rich_text>


tar --no-same-owner -zxvf HPC_21.0.RC1_CentOS-aarch64.tar.gz -C tmp

</rich_text>
		</node>
		<node custom_icon_id="0" foreground="" is_bold="False" name="xargs" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1626069907.65" ts_lastsave="1627521527.02" unique_id="19">
			<rich_text link="webs https://www.runoob.com/linux/linux-comm-xargs.html">xargs</rich_text>
			<rich_text> 

</rich_text>
			<rich_text foreground="#c57633">find </rich_text>
			<rich_text>$src_path -type f -name </rich_text>
			<rich_text foreground="#6a8759">&quot;*.sh&quot; </rich_text>
			<rich_text>| </rich_text>
			<rich_text foreground="#c57633">xargs </rich_text>
			<rich_text>chmod </rich_text>
			<rich_text foreground="#6897bb">500</rich_text>
			<rich_text>

</rich_text>
			<rich_text link="webs https://www.runoob.com/linux/linux-comm-xargs.html">https://www.runoob.com/linux/linux-comm-xargs.html</rich_text>
		</node>
		<node custom_icon_id="0" foreground="" is_bold="False" name="exec" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1626140478.34" ts_lastsave="1626140498.71" unique_id="30">
			<rich_text>exec </rich_text>
			<rich_text foreground="#6897bb">6</rich_text>
			<rich_text>&lt;&gt;</rich_text>
			<rich_text foreground="#6a8759">&quot;</rich_text>
			<rich_text>$lck</rich_text>
			<rich_text foreground="#6a8759">&quot;</rich_text>
			<rich_text>

</rich_text>
			<rich_text link="webs https://www.cnblogs.com/machangwei-8/p/10355422.html">exec命令详解</rich_text>
			<rich_text>
exec是直接用新的进程去代替原来的程序运行，运行完毕之后不回到原先的程序中去
 
 </rich_text>
		</node>
		<node custom_icon_id="0" foreground="" is_bold="False" name="flock" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1626141399.28" ts_lastsave="1626143913.64" unique_id="31">
			<rich_text>
</rich_text>
			<rich_text link="webs https://www.cnblogs.com/nickup/p/9804020.html">共享锁（读锁）和排他锁（写锁）</rich_text>
			<rich_text>
</rich_text>
			<rich_text link="webs https://blog.csdn.net/prettyshuang/article/details/45502109">强制性锁和建议性锁的区别</rich_text>
			<rich_text>
</rich_text>
			<rich_text link="webs https://blog.csdn.net/qq_37414405/article/details/83689965">linux中的文件锁(劝告性上锁和强制性上锁)</rich_text>
			<rich_text>


</rich_text>
			<rich_text link="webs https://www.cnblogs.com/embedded-linux/p/6731240.html">flock</rich_text>
			<rich_text>
</rich_text>
			<rich_text link="webs https://blog.csdn.net/fulinus/article/details/9901681">linux之flock命令</rich_text>
			<rich_text>

</rich_text>
			<rich_text link="webs http://blog.chinaunix.net/uid-24774106-id-3488489.html">从flock引发的一个bug谈起（1） 进程的文件描述符</rich_text>
		</node>
		<node custom_icon_id="0" foreground="" is_bold="False" name="ps" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1626144464.77" ts_lastsave="1626144497.34" unique_id="33">
			<rich_text>

</rich_text>
			<rich_text link="webs https://blog.csdn.net/VIP_WangSai/article/details/72616587">shell中的ps命令详解</rich_text>
			<rich_text>
ps c 列出程序时，显示每个程序真正的指令名称，而不包含路径，参数或常驻服务的标示。


</rich_text>
		</node>
		<node custom_icon_id="0" foreground="" is_bold="False" name="wc" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1626144542.34" ts_lastsave="1626144560.92" unique_id="34">
			<rich_text>

cat </rich_text>
			<rich_text foreground="#808080">*</rich_text>
			<rich_text> </rich_text>
			<rich_text foreground="#808080">|</rich_text>
			<rich_text> wc </rich_text>
			<rich_text foreground="#808080">-</rich_text>
			<rich_text>l 查询当前文件夹下的文件的总行数。
原理就是统计了文件中换行符的数量。
</rich_text>
		</node>
		<node custom_icon_id="0" foreground="" is_bold="False" name="ip" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1626144730.42" ts_lastsave="1626144734.74" unique_id="36">
			<rich_text>ip addr</rich_text>
		</node>
		<node custom_icon_id="0" foreground="" is_bold="False" name="if" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1626147404.26" ts_lastsave="1626159449.89" unique_id="38">
			<rich_text>
</rich_text>
			<rich_text link="webs https://www.runoob.com/linux/linux-shell-test.html">Shell test 命令</rich_text>
			<rich_text>

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

</rich_text>
			<rich_text justification="left"></rich_text>
			<rich_text>

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

判断function返回值

</rich_text>
			<rich_text foreground="#808080">#!/bin/bash

</rich_text>
			<rich_text>test() {
  return </rich_text>
			<rich_text foreground="#6897bb">1
</rich_text>
			<rich_text>}

</rich_text>
			<rich_text foreground="#cc7832">if ! </rich_text>
			<rich_text>test;</rich_text>
			<rich_text foreground="#cc7832">then
    </rich_text>
			<rich_text>echo </rich_text>
			<rich_text foreground="#6a8759">&quot;2333&quot;
</rich_text>
			<rich_text foreground="#cc7832">fi</rich_text>
			<rich_text>

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
if test

</rich_text>
			<rich_text foreground="#808080">#!/bin/bash

</rich_text>
			<rich_text>num1=</rich_text>
			<rich_text foreground="#6897bb">100
</rich_text>
			<rich_text>num2=</rich_text>
			<rich_text foreground="#6897bb">100
</rich_text>
			<rich_text foreground="#cc7832">if </rich_text>
			<rich_text>test $[num1] -eq $[num2]
</rich_text>
			<rich_text foreground="#808080">#if [ $[num1] -eq $[num2] ] 
</rich_text>
			<rich_text foreground="#cc7832">then
    </rich_text>
			<rich_text>echo </rich_text>
			<rich_text foreground="#6a8759">'两个数相等！'
</rich_text>
			<rich_text foreground="#cc7832">else
    </rich_text>
			<rich_text>echo </rich_text>
			<rich_text foreground="#6a8759">'两个数不相等！'
</rich_text>
			<rich_text foreground="#cc7832">fi

</rich_text>
			<rich_text>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</rich_text>
			<table char_offset="51" col_max="400" col_min="40">
				<row>
					<cell>-eq</cell>
					<cell>等于则为真</cell>
				</row>
				<row>
					<cell>-ne</cell>
					<cell>不等于则为真</cell>
				</row>
				<row>
					<cell>-gt</cell>
					<cell>大于则为真</cell>
				</row>
				<row>
					<cell>-ge</cell>
					<cell>大于等于则为真</cell>
				</row>
				<row>
					<cell>-lt</cell>
					<cell>小于则为真</cell>
				</row>
				<row>
					<cell>-le</cell>
					<cell>小于等于则为真</cell>
				</row>
				<row>
					<cell>参数</cell>
					<cell>说明</cell>
				</row>
			</table>
		</node>
		<node custom_icon_id="0" foreground="" is_bold="False" name="umask" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1626158514.44" ts_lastsave="1626158552.49" unique_id="41">
			<rich_text>
</rich_text>
			<rich_text link="webs https://www.cnblogs.com/sench/p/8933638.html">linux命令--umask</rich_text>
			<rich_text>

        在linux系统中，我们创建一个新的文件或者目录的时候，这些新的文件或目录都会有默认的访问权限，umask命令与文件和目录的默认访问权限有关。若用户创建一个文件，则文件的默认访问权限为 -rw-rw-rw- ，创建目录的默认权限 drwxrwxrwx ，而umask值则表明了需要从默认权限中去掉哪些权限来成为最终的默认权限值。
        
        </rich_text>
		</node>
		<node custom_icon_id="0" foreground="" is_bold="False" name="array" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1626337695.93" ts_lastsave="1626337772.76" unique_id="54">
			<rich_text>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

</rich_text>
			<rich_text weight="heavy">${!array[*]}</rich_text>
			<rich_text>

    array=(1 2 3)
    echo ${array[*]}

    echo ${!array[*]}

    array=(&quot;e&quot; &quot;b&quot; &quot;d&quot; &quot;a&quot;)
    echo ${array[*]}

    echo ${!array[*]}
</rich_text>
		</node>
	</node>
</cherrytree>
